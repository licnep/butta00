.. Automatically generated by code2rst.py
   code2rst.py src/connection.c doc/connection.rst
   Edit src/connection.c not this file!

.. currentmodule:: apsw

.. _connections:

Connections to a database
*************************

A :class:`Connection` encapsulates access to a database.  You then use
:class:`cursors <Cursor>` to issue queries against the database.

You can have multple :class:`Connections <Connection>` open against
the same database in the same process, across threads and in other
processes.

Connection class
================

.. index:: sqlite3_open_v2

.. class:: Connection(filename, flags=SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, vfs=None, statementcachesize=100)

  This object wraps a `sqlite3 pointer
  <https://sqlite.org/c3ref/sqlite3.html>`_.

  Opens the named database.  You can use ``:memory:`` to get a private temporary
  in-memory database that is not shared with any other connections.

  :param flags: One or more of the `open flags <https://sqlite.org/c3ref/c_open_autoproxy.html>`_ orred together
  :param vfs: The name of the `vfs <https://sqlite.org/c3ref/vfs.html>`_ to use.  If :const:`None` then the default
     vfs will be used.

  :param statementcachesize: Use zero to disable the statement cache,
    or a number larger than the total distinct SQL statements you
    execute frequently.

  .. seealso::

    * :attr:`apsw.connection_hooks`
    * :ref:`statementcache`
    * :ref:`vfs`

  Calls: :sqliteapi:`sqlite3_open_v2 <open>`

.. method:: Connection.__enter__() -> context

  You can use the database as a `context manager
  <http://docs.python.org/reference/datamodel.html#with-statement-context-managers>`_
  as defined in :pep:`0343`.  When you use *with* a transaction is
  started.  If the block finishes with an exception then the
  transaction is rolled back, otherwise it is committed.  For example::

    with connection:
        connection.cursor().execute("....")
        with connection:
            # nested is supported
            call_function(connection)
            connection.cursor().execute("...")
            with connection as db:
                # You can also use 'as'
                call_function2(db)
                db.cursor().execute("...")

  Behind the scenes the `savepoint
  <https://sqlite.org/lang_savepoint.html>`_ functionality introduced in
  SQLite 3.6.8 is used.

.. method:: Connection.__exit__() -> False

  Implements context manager in conjunction with
  :meth:`~Connection.__enter__`.  Any exception that happened in the
  *with* block is raised after commiting or rolling back the
  savepoint.

.. index:: sqlite3_backup_init

.. method:: Connection.backup(databasename, sourceconnection, sourcedatabasename)  -> backup

   Opens a :ref:`backup object <Backup>`.  All data will be copied from source
   database to this database.

   :param databasename: Name of the database.  This will be ``main`` for
     the main connection and the name you specified for `attached
     <https://sqlite.org/lang_attach.html>`_ databases.
   :param sourceconnection: The :class:`Connection` to copy a database from.
   :param sourcedatabasename: Name of the database in the source (eg ``main``).

   :rtype: :class:`backup`

   .. seealso::

     * :ref:`Backup`

   Calls: :sqliteapi:`sqlite3_backup_init <backup_finish.html#sqlite3backupf>`

.. index:: sqlite3_blob_open

.. method:: Connection.blobopen(database, table, column, rowid, writeable)  -> blob

   Opens a blob for :ref:`incremental I/O <blobio>`.

   :param database: Name of the database.  This will be ``main`` for
     the main connection and the name you specified for `attached
     <https://sqlite.org/lang_attach.html>`_ databases.
   :param table: The name of the table
   :param column: The name of the column
   :param rowid: The id that uniquely identifies the row.
   :param writeable: If True then you can read and write the blob.  If False then you can only read it.

   :rtype: :class:`blob`

   .. seealso::

     * :ref:`Blob I/O example <example-blobio>`
     * `SQLite row ids <https://sqlite.org/autoinc.html>`_

   Calls: :sqliteapi:`sqlite3_blob_open <blob_open>`

.. index:: sqlite3_changes

.. method:: Connection.changes() -> int

  Returns the number of database rows that were changed (or inserted
  or deleted) by the most recently completed INSERT, UPDATE, or DELETE
  statement.

  Calls: :sqliteapi:`sqlite3_changes <changes>`

.. index:: sqlite3_close

.. method:: Connection.close([force=False])

  Closes the database.  If there are any outstanding :class:`cursors
  <Cursor>`, :class:`blobs <blob>` or :class:`backups <backup>` then
  they are closed too.  It is normally not necessary to call this
  method as the database is automatically closed when there are no
  more references.  It is ok to call the method multiple times.

  If your user defined functions or collations have direct or indirect
  references to the Connection then it won't be automatically garbage
  collected because of circular referencing that can't be
  automatically broken.  Calling *close* will free all those objects
  and what they reference.

  SQLite is designed to survive power failures at even the most
  awkward moments.  Consequently it doesn't matter if it is closed
  when the process is exited, or even if the exit is graceful or
  abrupt.  In the worst case of having a transaction in progress, that
  transaction will be rolled back by the next program to open the
  database, reverting the database to a know good state.

  If *force* is *True* then any exceptions are ignored.

  Calls: :sqliteapi:`sqlite3_close <close>`

.. index:: sqlite3_collation_needed

.. method:: Connection.collationneeded(callable)

  *callable* will be called if a statement requires a `collation
  <http://en.wikipedia.org/wiki/Collation>`_ that hasn't been
  registered. Your callable will be passed two parameters. The first
  is the connection object. The second is the name of the
  collation. If you have the collation code available then call
  :meth:`Connection.createcollation`.

  This is useful for creating collations on demand.  For example you
  may include the `locale <http://en.wikipedia.org/wiki/Locale>`_ in
  the collation name, but since there are thousands of locales in
  popular use it would not be useful to :meth:`prereigster
  <Connection.createcollation>` them all.  Using
  :meth:`~Connection.collationneeded` tells you when you need to
  register them.

  .. seealso::

    * :meth:`~Connection.createcollation`

  Calls: :sqliteapi:`sqlite3_collation_needed <collation_needed>`

.. index:: sqlite3_db_config

.. method:: Connection.config(op[, *args])

    :param op: A `configuration operation
      <https://sqlite.org/c3ref/c_dbconfig_enable_fkey.html>`__
    :param args: Zero or more arguments as appropriate for *op*

    Calls: :sqliteapi:`sqlite3_db_config <db_config>`

.. index:: sqlite3_create_function_v2

.. method:: Connection.createaggregatefunction(name, factory[, numargs=-1])

  Registers an aggregate function.  Aggregate functions operate on all
  the relevant rows such as counting how many there are.

  :param name: The string name of the function.  It should be less than 255 characters
  :param callable: The function that will be called
  :param numargs: How many arguments the function takes, with -1 meaning any number

  When a query starts, the *factory* will be called and must return a tuple of 3 items:

    a context object
       This can be of any type

    a step function
       This function is called once for each row.  The first parameter
       will be the context object and the remaining parameters will be
       from the SQL statement.  Any value returned will be ignored.

    a final function
       This function is called at the very end with the context object
       as a parameter.  The value returned is set as the return for
       the function. The final function is always called even if an
       exception was raised by the step function. This allows you to
       ensure any resources are cleaned up.

  .. note::

    You can register the same named function but with different
    callables and *numargs*.  See
    :meth:`~Connection.createscalarfunction` for an example.

  .. seealso::

     * :ref:`Example <aggregate-example>`
     * :meth:`~Connection.createscalarfunction`

  Calls: :sqliteapi:`sqlite3_create_function_v2 <create_function>`

.. index:: sqlite3_create_collation_v2

.. method:: Connection.createcollation(name, callback)

  You can control how SQLite sorts (termed `collation
  <http://en.wikipedia.org/wiki/Collation>`_) when giving the
  ``COLLATE`` term to a `SELECT
  <https://sqlite.org/lang_select.html>`_.  For example your
  collation could take into account locale or do numeric sorting.

  The *callback* will be called with two items.  It should return -1
  if the first is less then the second, 0 if they are equal, and 1 if
  first is greater::

     def mycollation(one, two):
         if one < two:
             return -1
         if one == two:
             return 0
         if one > two:
             return 1

  .. seealso::

    * :ref:`Example <collation-example>`

  Calls: :sqliteapi:`sqlite3_create_collation_v2 <create_collation>`

.. index:: sqlite3_create_module_v2

.. method:: Connection.createmodule(name, datasource)

    Registers a virtual table.  See :ref:`virtualtables` for details.

    .. seealso::

       * :ref:`Example <example-vtable>`

    Calls: :sqliteapi:`sqlite3_create_module_v2 <create_module>`

.. index:: sqlite3_create_function_v2

.. method:: Connection.createscalarfunction(name, callable[, numargs=-1])

  Registers a scalar function.  Scalar functions operate on one set of paramaters once.

  :param name: The string name of the function.  It should be less than 255 characters
  :param callable: The function that will be called
  :param numargs: How many arguments the function takes, with -1 meaning any number

  .. note::

    You can register the same named function but with different
    *callable* and *numargs*.  For example::

      connection.createscalarfunction("toip", ipv4convert, 4)
      connection.createscalarfunction("toip", ipv6convert, 16)
      connection.createscalarfunction("toip", strconvert, -1)

    The one with the correct *numargs* will be called and only if that
    doesn't exist then the one with negative *numargs* will be called.

  .. seealso::

     * :ref:`Example <scalar-example>`
     * :meth:`~Connection.createaggregatefunction`

  Calls: :sqliteapi:`sqlite3_create_function_v2 <create_function>`

.. method:: Connection.cursor() -> Cursor

  Creates a new :class:`Cursor` object on this database.

  :rtype: :class:`Cursor`

.. index:: sqlite3_db_filename

.. method:: Connection.db_filename(name) -> String

  Returns the full filename of the named (attached) database.  The
  main database is named "main".

  Calls: :sqliteapi:`sqlite3_db_filename <db_filename>`

.. index:: sqlite3_enable_load_extension

.. method:: Connection.enableloadextension(enable)

  Enables/disables `extension loading
  <https://sqlite.org/cvstrac/wiki/wiki?p=LoadableExtensions>`_
  which is disabled by default.

  :param enable: If True then extension loading is enabled, else it is disabled.

  .. seealso::

    * :meth:`~Connection.loadextension`

  Calls: :sqliteapi:`sqlite3_enable_load_extension <enable_load_extension>`

.. index:: sqlite3_file_control

.. method:: Connection.filecontrol(dbname, op, pointer) -> bool

  Calls the :meth:`~VFSFile.xFileControl` method on the :ref:`VFS`
  implementing :class:`file access <VFSFile>` for the database.

  :param dbname: The name of the database to affect (eg "main", "temp", attached name)
  :param op: A `numeric code
    <https://sqlite.org/c3ref/c_fcntl_lockstate.html>`_ with values less
    than 100 reserved for SQLite internal use.
  :param pointer: A number which is treated as a ``void pointer`` at the C level.

  :returns: True or False indicating if the VFS understood the op.

  If you want data returned back then the *pointer* needs to point to
  something mutable.  Here is an example using `ctypes
  <http://www.python.org/doc/2.5.2/lib/module-ctypes.html>`_ of
  passing a Python dictionary to :meth:`~VFSFile.xFileControl` which
  can then modify the dictionary to set return values::

    obj={"foo": 1, 2: 3}                 # object we want to pass
    objwrap=ctypes.py_object(obj)        # objwrap must live before and after the call else
                                         # it gets garbage collected
    connection.filecontrol(
             "main",                     # which db
             123,                        # our op code
             ctypes.addressof(objwrap))  # get pointer

  The :meth:`~VFSFile.xFileControl` method then looks like this::

    def xFileControl(self, op, pointer):
        if op==123:                      # our op code
            obj=ctypes.py_object.from_address(pointer).value
            # play with obj - you can use id() to verify it is the same
            print obj["foo"]
            obj["result"]="it worked"
	    return True
        else:
            # pass to parent/superclass
            return super(MyFile, self).xFileControl(op, pointer)

  This is how you set the chunk size by which the database grows.  Do
  not combine it into one line as the c_int would be garbage collected
  before the filecontrol call is made::

     chunksize=ctypes.c_int(32768)
     connection.filecontrol("main", apsw.SQLITE_FCNTL_CHUNK_SIZE, ctypes.addressof(chunksize))

  Calls: :sqliteapi:`sqlite3_file_control <file_control>`

.. index:: sqlite3_db_filename

.. attribute:: Connection.filename

  The filename of the  database.

  Calls: :sqliteapi:`sqlite3_db_filename <db_filename>`

.. index:: sqlite3_get_autocommit

.. method:: Connection.getautocommit() -> bool

  Returns if the Connection is in auto commit mode (ie not in a transaction).

  Calls: :sqliteapi:`sqlite3_get_autocommit <get_autocommit>`

.. method:: Connection.getexectrace() -> callable or None

  Returns the currently installed (via :meth:`~Connection.setexectrace`)
  execution tracer.

  .. seealso::

    * :ref:`tracing`

.. method:: Connection.getrowtrace() -> callable or None

  Returns the currently installed (via :meth:`~Connection.setrowtrace`)
  row tracer.

  .. seealso::

    * :ref:`tracing`

.. index:: sqlite3_interrupt

.. method:: Connection.interrupt()

  Causes any pending operations on the database to abort at the
  earliest opportunity. You can call this from any thread.  For
  example you may have a long running query when the user presses the
  stop button in your user interface.  :exc:`InterruptError`
  will be raised in the query that got interrupted.

  Calls: :sqliteapi:`sqlite3_interrupt <interrupt>`

.. index:: sqlite3_last_insert_rowid

.. method:: Connection.last_insert_rowid() -> int

  Returns the integer key of the most recent insert in the database.

  Calls: :sqliteapi:`sqlite3_last_insert_rowid <last_insert_rowid>`

.. index:: sqlite3_limit

.. method:: Connection.limit(id[, newval]) -> int

  If called with one parameter then the current limit for that *id* is
  returned.  If called with two then the limit is set to *newval*.

  :param id: One of the `runtime limit ids <https://sqlite.org/c3ref/c_limit_attached.html>`_
  :param newval: The new limit.  This is a 32 bit signed integer even on 64 bit platforms.

  :returns: The limit in place on entry to the call.

  .. seealso::

    * :ref:`Example <example-limit>`

  Calls: :sqliteapi:`sqlite3_limit <limit>`

.. index:: sqlite3_load_extension

.. method:: Connection.loadextension(filename[, entrypoint])

  Loads *filename* as an `extension <https://sqlite.org/cvstrac/wiki/wiki?p=LoadableExtensions>`_

  :param filename: The file to load.  This must be Unicode or Unicode compatible

  :param entrypoint: The initialization method to call.  If this
    parameter is not supplied then the SQLite default of
    ``sqlite3_extension_init`` is used.

  :raises ExtensionLoadingError: If the extension could not be
    loaded.  The exception string includes more details.

  .. seealso::

    * :meth:`~Connection.enableloadextension`

  Calls: :sqliteapi:`sqlite3_load_extension <load_extension>`

.. attribute:: Connection.open_flags

  The integer flags used to open the database.

.. attribute:: Connection.open_vfs

  The string name of the vfs used to open the database.

.. index:: sqlite3_overload_function

.. method:: Connection.overloadfunction(name, nargs)

  Registers a placeholder function so that a virtual table can provide an implementation via
  :meth:`VTTable.FindFunction`.

  :param name: Function name
  :param nargs: How many arguments the function takes

  Due to :cvstrac:`3507` underlying errors will not be returned.

  Calls: :sqliteapi:`sqlite3_overload_function <overload_function>`

.. index:: sqlite3_db_readonly

.. method:: Connection.readonly(name) -> bool

  True or False if the named (attached) database was opened readonly or file
  permissions don't allow writing.  The main database is named "main".

  An exception is raised if the database doesn't exist.

  Calls: :sqliteapi:`sqlite3_db_readonly <db_readonly>`

.. index:: sqlite3_set_authorizer

.. method:: Connection.setauthorizer(callable)

  While `preparing <https://sqlite.org/c3ref/prepare.html>`_
  statements, SQLite will call any defined authorizer to see if a
  particular action is ok to be part of the statement.

  Typical usage would be if you are running user supplied SQL and want
  to prevent harmful operations.  You should also
  set the :class:`statementcachesize <Connection>` to zero.

  The authorizer callback has 5 parameters:

    * An `operation code <https://sqlite.org/c3ref/c_alter_table.html>`_
    * A string (or None) dependent on the operation `(listed as 3rd) <https://sqlite.org/c3ref/c_alter_table.html>`_
    * A string (or None) dependent on the operation `(listed as 4th) <https://sqlite.org/c3ref/c_alter_table.html>`_
    * A string name of the database (or None)
    * Name of the innermost trigger or view doing the access (or None)

  The authorizer callback should return one of :const:`SQLITE_OK`,
  :const:`SQLITE_DENY` or :const:`SQLITE_IGNORE`.
  (:const:`SQLITE_DENY` is returned if there is an error in your
  Python code).

  .. seealso::

    * :ref:`Example <authorizer-example>`
    * :ref:`statementcache`

  Calls: :sqliteapi:`sqlite3_set_authorizer <set_authorizer>`

.. index:: sqlite3_busy_handler

.. method:: Connection.setbusyhandler(callable)

   Sets the busy handler to callable. callable will be called with one
   integer argument which is the number of prior calls to the busy
   callback for the same lock. If the busy callback returns something
   that evaluates to False, then SQLite returns :const:`SQLITE_BUSY` to the
   calling code.. If the callback returns something that evaluates to
   True, then SQLite tries to open the table again and the cycle
   repeats.

   If you previously called :meth:`~Connection.setbusytimeout` then
   calling this overrides that.

   .. seealso::

     * :meth:`Connection.setbusytimeout`
     * :ref:`Busy handling <busyhandling>`

   Calls: :sqliteapi:`sqlite3_busy_handler <busy_handler>`

.. index:: sqlite3_busy_timeout

.. method:: Connection.setbusytimeout(millseconds)

  If the database is locked such as when another connection is making
  changes, SQLite will keep retrying.  This sets the maximum amount of
  time SQLite will keep retrying before giving up.  If the database is
  still busy then :class:`apsw.BusyError` will be returned.

  :param milliseconds: Maximum thousandths of a second to wait.

  If you previously called :meth:`~Connection.setbusyhandler` then
  calling this overrides that.

  .. seealso::

     * :meth:`Connection.setbusyhandler`
     * :ref:`Busy handling <busyhandling>`

  Calls: :sqliteapi:`sqlite3_busy_timeout <busy_timeout>`

.. index:: sqlite3_commit_hook

.. method:: Connection.setcommithook(callable)

  *callable* will be called just before a commit.  It should return
  zero for the commit to go ahead and non-zero for it to be turned
  into a rollback. In the case of an exception in your callable, a
  non-zero (ie rollback) value is returned.

  .. seealso::

    * :ref:`Example <example-commithook>`

  Calls: :sqliteapi:`sqlite3_commit_hook <commit_hook>`

.. method:: Connection.setexectrace(callable)

  *callable* is called with the cursor, statement and bindings for
  each :meth:`~Cursor.execute` or :meth:`~Cursor.executemany` on this
  Connection, unless the :class:`Cursor` installed its own
  tracer. Your execution tracer can also abort execution of a
  statement.

  If *callable* is :const:`None` then any existing execution tracer is
  removed.

  .. seealso::

    * :ref:`tracing`
    * :ref:`rowtracer`
    * :meth:`Cursor.setexectrace`

.. index:: sqlite3_profile

.. method:: Connection.setprofile(callable)

  Sets a callable which is invoked at the end of execution of each
  statement and passed the statement string and how long it took to
  execute. (The execution time is in nanoseconds.) Note that it is
  called only on completion. If for example you do a ``SELECT`` and
  only read the first result, then you won't reach the end of the
  statement.

  Calls: :sqliteapi:`sqlite3_profile <profile>`

.. index:: sqlite3_progress_handler

.. method:: Connection.setprogresshandler(callable[, nsteps=20])

  Sets a callable which is invoked every *nsteps* SQLite
  inststructions. The callable should return a non-zero value to abort
  or zero to continue. (If there is an error in your Python *callable*
  then non-zero will be returned).

  .. seealso::

     * :ref:`Example <example-progress-handler>`

  Calls: :sqliteapi:`sqlite3_progress_handler <progress_handler>`

.. index:: sqlite3_rollback_hook

.. method:: Connection.setrollbackhook(callable)

  Sets a callable which is invoked during a rollback.  If *callable*
  is :const:`None` then any existing rollback hook is removed.

  The *callable* is called with no parameters and the return value is ignored.

  Calls: :sqliteapi:`sqlite3_rollback_hook <commit_hook>`

.. method:: Connection.setrowtrace(callable)

  *callable* is called with the cursor and row being returned for
  :class:`cursors <Cursor>` associated with this Connection, unless
  the Cursor installed its own tracer.  You can change the data that
  is returned or cause the row to be skipped altogether.

  If *callable* is :const:`None` then any existing row tracer is
  removed.

  .. seealso::

    * :ref:`tracing`
    * :ref:`rowtracer`
    * :meth:`Cursor.setexectrace`

.. index:: sqlite3_update_hook

.. method:: Connection.setupdatehook(callable)

  Calls *callable* whenever a row is updated, deleted or inserted.  If
  *callable* is :const:`None` then any existing update hook is
  removed.  The update hook cannot make changes to the database while
  the query is still executing, but can record them for later use or
  apply them in a different connection.

  The update hook is called with 4 paramaters:

    type (int)
      :const:`SQLITE_INSERT`, :const:`SQLITE_DELETE` or :const:`SQLITE_UPDATE`
    database name (string)
      This is ``main`` for the database or the name specified in
      `ATTACH <https://sqlite.org/lang_attach.html>`_
    table name (string)
      The table on which the update happened
    rowid (64 bit integer)
      The affected row

  .. seealso::

      * :ref:`Example <example-updatehook>`

  Calls: :sqliteapi:`sqlite3_update_hook <update_hook>`

.. index:: sqlite3_wal_hook

.. method:: Connection.setwalhook(callable)

 *callable* will be called just after data is committed in :ref:`wal`
 mode.  It should return :const:`SQLITE_OK` or an error code.  The
 callback is called with 3 parameters:

   * The Connection
   * The database name (eg "main" or the name of an attached database)
   * The number of pages in the wal log

 You can pass in None in order to clear an existing hook.

 Calls: :sqliteapi:`sqlite3_wal_hook <wal_hook>`

.. method:: Connection.sqlite3pointer() -> int

  Returns the underlying `sqlite3 *
  <https://sqlite.org/c3ref/sqlite3.html>`_ for the connection. This
  method is useful if there are other C level libraries in the same
  process and you want them to use the APSW connection handle. The
  value is returned as a number using :meth:`PyLong_FromVoidPtr` under the
  hood. You should also ensure that you increment the reference count on
  the :class:`Connection` for as long as the other libraries are using
  the pointer.  It is also a very good idea to call
  :meth:`sqlitelibversion` and ensure it is the same as the other
  libraries.

.. index:: sqlite3_db_status

.. method:: Connection.status(op, reset=False) -> (int, int)

  Returns current and highwater measurements for the database.

  :param op: A `status parameter <https://sqlite.org/c3ref/c_dbstatus_options.html>`_
  :param reset: If *True* then the highwater is set to the current value
  :returns: A tuple of current value and highwater value

  .. seealso::

    The :func:`status` example which works in exactly the same way.

    * :ref:`Status example <example-status>`

  Calls: :sqliteapi:`sqlite3_db_status <db_status>`

.. index:: sqlite3_total_changes

.. method:: Connection.totalchanges() -> int

  Returns the total number of database rows that have be modified,
  inserted, or deleted since the database connection was opened.

  Calls: :sqliteapi:`sqlite3_total_changes <total_changes>`

.. index:: sqlite3_wal_autocheckpoint

.. method:: Connection.wal_autocheckpoint(n)

    Sets how often the :ref:`wal` checkpointing is run.

    :param n: A number representing the checkpointing interval or
      zero/negative to disable auto checkpointing.

    Calls: :sqliteapi:`sqlite3_wal_autocheckpoint <wal_autocheckpoint>`

.. index:: sqlite3_wal_checkpoint_v2

.. method:: Connection.wal_checkpoint(dbname=None, mode=apsw.SQLITE_CHECKPOINT_PASSIVE) -> ( int, int )

    Does a WAL checkpoint.  Has no effect if the database(s) are not in WAL mode.

    :param dbname:  The name of the database or all databases if None

    :param mode: One of the `checkpoint modes <https://sqlite.org/c3ref/wal_checkpoint_v2.html>`__.

    :return: A tuple of the size of the WAL log in frames and the
       number of frames checkpointed as described in the
       `documentation
       <https://sqlite.org/c3ref/wal_checkpoint_v2.html>`__.

    Calls: :sqliteapi:`sqlite3_wal_checkpoint_v2 <wal_checkpoint_v2>`

