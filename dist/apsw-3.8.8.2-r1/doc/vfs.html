<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Virtual File System (VFS) &mdash; APSW 3.8.8.2-r1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.8.8.2-r1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="copyright" title="Copyright" href="copyright.html" />
    <link rel="top" title="APSW 3.8.8.2-r1 documentation" href="index.html" />
    <link rel="next" title="Shell" href="shell.html" />
    <link rel="prev" title="Virtual Tables" href="vtable.html" />
 
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-26815066-1']);
  _gaq.push(['_trackPageview']);
</script>

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="shell.html" title="Shell"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="vtable.html" title="Virtual Tables"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">APSW 3.8.8.2-r1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="virtual-file-system-vfs">
<span id="vfs"></span><h1>Virtual File System (VFS)<a class="headerlink" href="#virtual-file-system-vfs" title="Permalink to this headline">¶</a></h1>
<p>SQLite 3.6 has new <a class="reference external" href="https://sqlite.org/c3ref/vfs.html">VFS functionality</a> which defines the interface
between the SQLite core and the underlying operating system. The
majority of the functionality deals with files. APSW exposes this
functionality letting you provide your own routines. You can also
<em>inherit</em> from an existing vfs making it easy to augment or override
specific routines. For example you could obfuscate your database by
XORing the data implemented by augmenting the read and write
methods. The method names are exactly the same as SQLite uses making
it easier to read the SQLite documentation, trouble tickets, web
searches or mailing lists. The SQLite convention results in names like
xAccess, xCurrentTime and xWrite.</p>
<p>You specify which VFS to use as a parameter to the <a class="reference internal" href="connection.html#apsw.Connection" title="apsw.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a>
constructor.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">db</span><span class="o">=</span><span class="n">apsw</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="s">&quot;file&quot;</span><span class="p">,</span> <span class="n">vfs</span><span class="o">=</span><span class="s">&quot;myvfs&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The easiest way to get started is to make a <a class="reference internal" href="#apsw.VFS" title="apsw.VFS"><tt class="xref py py-class docutils literal"><span class="pre">VFS</span></tt></a> derived class
that inherits from the default vfs.  Then override methods you want to
change behaviour of.  If you want to just change how file operations
are done then you have to override <a class="reference internal" href="#apsw.VFS.xOpen" title="apsw.VFS.xOpen"><tt class="xref py py-meth docutils literal"><span class="pre">VFS.xOpen()</span></tt></a> to return a file
instance that has your overridden <a class="reference internal" href="#apsw.VFSFile" title="apsw.VFSFile"><tt class="xref py py-class docutils literal"><span class="pre">VFSFile</span></tt></a> methods.  The
<a class="reference internal" href="example.html#example-vfs"><em>example</em></a> demonstrates obfuscating the database
file contents.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">All strings supplied and returned to <a class="reference internal" href="#apsw.VFS" title="apsw.VFS"><tt class="xref py py-class docutils literal"><span class="pre">VFS</span></tt></a>/<a class="reference internal" href="#apsw.VFSFile" title="apsw.VFSFile"><tt class="xref py py-class docutils literal"><span class="pre">VFSFile</span></tt></a>
routines are treated as Unicode.</p>
</div>
<div class="section" id="exceptions-and-errors">
<h2>Exceptions and errors<a class="headerlink" href="#exceptions-and-errors" title="Permalink to this headline">¶</a></h2>
<p>To return an error from any routine you should raise an exception. The
exception will be translated into the appropriate SQLite error code
for SQLite. To return a specific SQLite error code use
<a class="reference internal" href="apsw.html#apsw.exceptionfor" title="apsw.exceptionfor"><tt class="xref py py-meth docutils literal"><span class="pre">exceptionfor()</span></tt></a>.  If the exception does not map to any specific
error code then <tt class="xref py py-const docutils literal"><span class="pre">SQLITE_ERROR</span></tt> which corresponds to
<a class="reference internal" href="exceptions.html#apsw.SQLError" title="apsw.SQLError"><tt class="xref py py-exc docutils literal"><span class="pre">SQLError</span></tt></a> is returned to SQLite.</p>
<p>The SQLite code that deals with VFS errors behaves in varying
ways. Some routines have no way to return an error (eg <a class="reference external" href="https://sqlite.org/c3ref/vfs.html">xDlOpen</a> just returns zero/NULL on
being unable to load a library, <a class="reference external" href="https://sqlite.org/c3ref/vfs.html">xSleep</a> has no error return
parameter), others are unified (eg almost any
error in xWrite will be returned to the user as disk full
error). Sometimes errors are ignored as they are harmless such as when
a journal can&#8217;t be deleted after a commit (the journal is marked as
obsolete before being deleted).  Simple operations such as opening a
database can result in many different VFS function calls such as hot
journals being detected, locking, and read/writes for
playback/rollback.</p>
<p>To avoid confusion with exceptions being raised in the VFS and
exceptions from normal code to open Connections or execute SQL
queries, VFS exceptions are not raised in the normal way. (If they
were, only one could be raised and it would obscure whatever
exceptions the <a class="reference internal" href="connection.html#apsw.Connection" title="apsw.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> open or SQL query execute wanted to
raise.)  Instead the <a class="reference internal" href="#apsw.VFS.excepthook" title="apsw.VFS.excepthook"><tt class="xref py py-meth docutils literal"><span class="pre">VFS.excepthook()</span></tt></a> or
<a class="reference internal" href="#apsw.VFSFile.excepthook" title="apsw.VFSFile.excepthook"><tt class="xref py py-meth docutils literal"><span class="pre">VFSFile.excepthook()</span></tt></a> method is called with a tuple of exception
type, exception value and exception traceback. The default
implementation of <tt class="docutils literal"><span class="pre">excepthook</span></tt> calls <tt class="docutils literal"><span class="pre">sys.excepthook()</span></tt> which
under Python 2 shows the stack trace and under Python 3 merely prints
the exception value. (If <tt class="docutils literal"><span class="pre">sys.excepthook</span></tt> fails then
<tt class="docutils literal"><span class="pre">PyErr_Display()</span></tt> is called.)</p>
<p>In normal VFS usage there will be no exceptions raised, or specific
expected ones which APSW clears after noting them and returning the
appropriate value back to SQLite. The exception hooking behaviour
helps you find issues in your code or unexpected behaviour of the
external environment. Remember that <a class="reference internal" href="exceptions.html#augmentedstacktraces"><em>augmented stack traces</em></a> are available which significantly increase
detail about the exceptions.</p>
<p>As an example, lets say you have a divide by zero error in your xWrite
routine. The table below shows what happens with time going down and
across.</p>
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="26%" />
<col width="37%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Python Query Code</th>
<th class="head">SQLite and APSW C code</th>
<th class="head">Python VFS code</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">cursor.execute(&quot;update</span> <span class="pre">table</span> <span class="pre">set</span> <span class="pre">foo=3&quot;)</span></tt></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>SQLite starts executing query</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>Your VFS routines are called</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>Your xWrite divides by zero</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td><a class="reference internal" href="#apsw.VFSFile.excepthook" title="apsw.VFSFile.excepthook"><tt class="xref py py-meth docutils literal"><span class="pre">VFSFile.excepthook()</span></tt></a> is called with
ZeroDivision exception</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td><tt class="xref py py-const docutils literal"><span class="pre">SQLITE_ERROR</span></tt> (closest
matching SQLite error code) is
returned to SQLite by APSW</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>SQLite error handling and
recovery operates which calls
more VFS routines.</td>
<td>More VFS routines are called.  Any
exceptions in these routines will result in
<a class="reference internal" href="#apsw.VFSFile.excepthook" title="apsw.VFSFile.excepthook"><tt class="xref py py-meth docutils literal"><span class="pre">VFSFile.excepthook()</span></tt></a> being called with
them.</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>SQLite returns
<tt class="xref py py-const docutils literal"><span class="pre">SQLITE_FULL</span></tt> to APSW</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>APSW returns <a class="reference internal" href="exceptions.html#apsw.FullError" title="apsw.FullError"><tt class="xref py py-class docutils literal"><span class="pre">apsw.FullError</span></tt></a></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="vfs-class">
<h2>VFS class<a class="headerlink" href="#vfs-class" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-0"></span><dl class="class">
<dt id="apsw.VFS">
<em class="property">class </em><tt class="descname">VFS</tt><big>(</big><em>name</em><span class="optional">[</span>, <em>base=None</em>, <em>makedefault=False</em>, <em>maxpathname=1024</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#apsw.VFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides operating system access.  You can get an overview in the
<a class="reference external" href="https://sqlite.org/c3ref/vfs.html">SQLite documentation</a>.  To
create a VFS your Python class must inherit from <a class="reference internal" href="#apsw.VFS" title="apsw.VFS"><tt class="xref py py-class docutils literal"><span class="pre">VFS</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name</strong> &#8211; The name to register this vfs under.  If the name
already exists then this vfs will replace the prior one of the
same name.  Use <a class="reference internal" href="apsw.html#apsw.vfsnames" title="apsw.vfsnames"><tt class="xref py py-meth docutils literal"><span class="pre">apsw.vfsnames()</span></tt></a> to get a list of
registered vfs names.  :param base: If you would like to
inherit behaviour from an already registered vfs then give
their name.  To inherit from the default vfs, use a zero
length string <tt class="docutils literal"><span class="pre">&quot;&quot;</span></tt> as the name.  :param makedefault: If true
then this vfs will be registered as the default, and will be
used by any opens that don&#8217;t specify a vfs.  :param
maxpathname: The maximum length of database name in bytes when
represented in UTF-8.  If a pathname is passed in longer than
this value then SQLite will not <a class="reference external" href="https://sqlite.org/src/tktview/c060923a5422590b3734eb92eae0c94934895b68">be able to open it</a>.</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Raises ValueError:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">If <em>base</em> is not <tt class="xref py py-const docutils literal"><span class="pre">None</span></tt> and the named vfs is not
currently registered.</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Calls:</dt>
<dd><ul class="first last simple">
<li><a class="reference external" href="https://sqlite.org/c3ref/vfs_find.html">sqlite3_vfs_register</a></li>
<li><a class="reference external" href="https://sqlite.org/c3ref/vfs_find.html">sqlite3_vfs_find</a></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="apsw.VFS.excepthook">
<tt class="descclassname">VFS.</tt><tt class="descname">excepthook</tt><big>(</big><em>etype</em>, <em>evalue</em>, <em>etraceback</em><big>)</big><a class="headerlink" href="#apsw.VFS.excepthook" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when there has been an exception in a <a class="reference internal" href="#apsw.VFS" title="apsw.VFS"><tt class="xref py py-class docutils literal"><span class="pre">VFS</span></tt></a> routine.
The default implementation calls <tt class="docutils literal"><span class="pre">sys.excepthook</span></tt> and if that
fails then <tt class="docutils literal"><span class="pre">PyErr_Display</span></tt>.  The three arguments correspond to
what <tt class="docutils literal"><span class="pre">sys.exc_info()</span></tt> would return.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>etype</strong> &#8211; The exception type</li>
<li><strong>evalue</strong> &#8211; The exception  value</li>
<li><strong>etraceback</strong> &#8211; The exception traceback.  Note this
includes all frames all the way up to the thread being started.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="index-1"></span><dl class="method">
<dt id="apsw.VFS.unregister">
<tt class="descclassname">VFS.</tt><tt class="descname">unregister</tt><big>(</big><big>)</big><a class="headerlink" href="#apsw.VFS.unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregisters the VFS making it unavailable to future database
opens. You do not need to call this as the VFS is automatically
unregistered by when the VFS has no more references or open
datatabases using it. It is however useful to call if you have made
your VFS be the default and wish to immediately make it be
unavailable. It is safe to call this routine multiple times.</p>
<p>Calls: <a class="reference external" href="https://sqlite.org/c3ref/vfs_find.html">sqlite3_vfs_unregister</a></p>
</dd></dl>

<dl class="method">
<dt id="apsw.VFS.xAccess">
<tt class="descclassname">VFS.</tt><tt class="descname">xAccess</tt><big>(</big><em>pathname</em>, <em>flags</em><big>)</big> &rarr; bool<a class="headerlink" href="#apsw.VFS.xAccess" title="Permalink to this definition">¶</a></dt>
<dd><p>SQLite wants to check access permissions.  Return True or False
accordingly.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pathname</strong> &#8211; File or directory to check</li>
<li><strong>flags</strong> &#8211; One of the <a class="reference external" href="https://sqlite.org/c3ref/c_access_exists.html">access flags</a></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="apsw.VFS.xCurrentTime">
<tt class="descclassname">VFS.</tt><tt class="descname">xCurrentTime</tt><big>(</big><big>)</big> &rarr; float<a class="headerlink" href="#apsw.VFS.xCurrentTime" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <a class="reference external" href="http://en.wikipedia.org/wiki/Julian_day">Julian Day Number</a> as a floating point
number where the integer portion is the day and the fractional part
is the time. Do not adjust for timezone (ie use <a class="reference external" href="http://en.wikipedia.org/wiki/Universal_Time">UTC</a>).</p>
</dd></dl>

<dl class="method">
<dt id="apsw.VFS.xDelete">
<tt class="descclassname">VFS.</tt><tt class="descname">xDelete</tt><big>(</big><em>filename</em>, <em>syncdir</em><big>)</big><a class="headerlink" href="#apsw.VFS.xDelete" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the named file.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>SQLite has 3 different behaviours depending on version for how to handle missing files.</p>
<table border="1" class="last docutils">
<colgroup>
<col width="45%" />
<col width="55%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>SQLite &lt; 3.7.8</td>
<td>Raise an <a class="reference internal" href="exceptions.html#apsw.IOError" title="apsw.IOError"><tt class="xref py py-exc docutils literal"><span class="pre">IOError</span></tt></a> if the file does not
exist.</td>
</tr>
<tr class="row-even"><td>SQLite &gt;= 3.7.8 and SQLite &lt; 3.7.15</td>
<td>Do not raise an exception</td>
</tr>
<tr class="row-odd"><td>SQLite &gt;= 3.7.15</td>
<td>Raise an <a class="reference internal" href="exceptions.html#apsw.IOError" title="apsw.IOError"><tt class="xref py py-exc docutils literal"><span class="pre">IOError</span></tt></a> exception with
extendedresult <tt class="xref py py-const docutils literal"><span class="pre">SQLITE_IOERR_DELETE_NOENT</span></tt></td>
</tr>
</tbody>
</table>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> &#8211; File to delete</li>
<li><strong>syncdir</strong> &#8211; If True then the directory should be synced
ensuring that the file deletion has been recorded on the disk
platters.  ie if there was an immediate power failure after this
call returns, on a reboot the file would still be deleted.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="apsw.VFS.xDlClose">
<tt class="descclassname">VFS.</tt><tt class="descname">xDlClose</tt><big>(</big><em>handle</em><big>)</big><a class="headerlink" href="#apsw.VFS.xDlClose" title="Permalink to this definition">¶</a></dt>
<dd><p>Close and unload the library corresponding to the handle you
returned from <a class="reference internal" href="#apsw.VFS.xDlOpen" title="apsw.VFS.xDlOpen"><tt class="xref py py-meth docutils literal"><span class="pre">xDlOpen()</span></tt></a>.  You can use ctypes to do
this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">xDlClose</span><span class="p">(</span><span class="n">handle</span><span class="p">):</span>
   <span class="c"># Note leading underscore in _ctypes</span>
   <span class="n">_ctypes</span><span class="o">.</span><span class="n">dlclose</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span>       <span class="c"># Linux/Mac/Unix</span>
   <span class="n">_ctypes</span><span class="o">.</span><span class="n">FreeLibrary</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span>   <span class="c"># Windows</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="apsw.VFS.xDlError">
<tt class="descclassname">VFS.</tt><tt class="descname">xDlError</tt><big>(</big><big>)</big> &rarr; string<a class="headerlink" href="#apsw.VFS.xDlError" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an error string describing the last error of
<a class="reference internal" href="#apsw.VFS.xDlOpen" title="apsw.VFS.xDlOpen"><tt class="xref py py-meth docutils literal"><span class="pre">xDlOpen()</span></tt></a> or <a class="reference internal" href="#apsw.VFS.xDlSym" title="apsw.VFS.xDlSym"><tt class="xref py py-meth docutils literal"><span class="pre">xDlSym()</span></tt></a> (ie they returned
zero/NULL). If you do not supply this routine then SQLite provides
a generic message. To implement this method, catch exceptions in
<a class="reference internal" href="#apsw.VFS.xDlOpen" title="apsw.VFS.xDlOpen"><tt class="xref py py-meth docutils literal"><span class="pre">xDlOpen()</span></tt></a> or <a class="reference internal" href="#apsw.VFS.xDlSym" title="apsw.VFS.xDlSym"><tt class="xref py py-meth docutils literal"><span class="pre">xDlSym()</span></tt></a>, turn them into
strings, save them, and return them in this routine.  If you have
an error in this routine or return None then SQLite&#8217;s generic
message will be used.</p>
</dd></dl>

<dl class="method">
<dt id="apsw.VFS.xDlOpen">
<tt class="descclassname">VFS.</tt><tt class="descname">xDlOpen</tt><big>(</big><em>filename</em><big>)</big> &rarr; number<a class="headerlink" href="#apsw.VFS.xDlOpen" title="Permalink to this definition">¶</a></dt>
<dd><p>Load the shared library. You should return a number which will be
treated as a void pointer at the C level. On error you should
return 0 (NULL). The number is passed as is to
<a class="reference internal" href="#apsw.VFS.xDlSym" title="apsw.VFS.xDlSym"><tt class="xref py py-meth docutils literal"><span class="pre">xDlSym()</span></tt></a>/<a class="reference internal" href="#apsw.VFS.xDlClose" title="apsw.VFS.xDlClose"><tt class="xref py py-meth docutils literal"><span class="pre">xDlClose()</span></tt></a> so it can represent
anything that is convenient for you (eg an index into an
array). You can use ctypes to load a library:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">xDlOpen</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
   <span class="k">return</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">cdll</span><span class="o">.</span><span class="n">LoadLibrary</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">_handle</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="apsw.VFS.xDlSym">
<tt class="descclassname">VFS.</tt><tt class="descname">xDlSym</tt><big>(</big><em>handle</em>, <em>symbol</em><big>)</big> &rarr; address<a class="headerlink" href="#apsw.VFS.xDlSym" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the address of the named symbol which will be called by
SQLite. On error you should return 0 (NULL). You can use ctypes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">xDlSym</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
   <span class="k">return</span> <span class="n">_ctypes</span><span class="o">.</span><span class="n">dlsym</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>  <span class="c"># Linux/Unix/Mac etc (note leading underscore)</span>
   <span class="k">return</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">win32</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetProcAddress</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>  <span class="c"># Windows</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>handle</strong> &#8211; The value returned from an earlier <a class="reference internal" href="#apsw.VFS.xDlOpen" title="apsw.VFS.xDlOpen"><tt class="xref py py-meth docutils literal"><span class="pre">xDlOpen()</span></tt></a> call</li>
<li><strong>symbol</strong> &#8211; A string</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">An int/long with the symbol address</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="apsw.VFS.xFullPathname">
<tt class="descclassname">VFS.</tt><tt class="descname">xFullPathname</tt><big>(</big><em>name</em><big>)</big> &rarr; string<a class="headerlink" href="#apsw.VFS.xFullPathname" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the absolute pathname for name.  You can use <tt class="docutils literal"><span class="pre">os.path.abspath</span></tt> to do this.</p>
</dd></dl>

<dl class="method">
<dt id="apsw.VFS.xGetLastError">
<tt class="descclassname">VFS.</tt><tt class="descname">xGetLastError</tt><big>(</big><big>)</big> &rarr; string<a class="headerlink" href="#apsw.VFS.xGetLastError" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is to return text describing the last error that
happened in this thread. If not implemented SQLite&#8217;s more generic
message is used. However the method is <a class="reference external" href="https://sqlite.org/cvstrac/tktview?tn=3337">never called</a> by SQLite.</p>
</dd></dl>

<dl class="method">
<dt id="apsw.VFS.xGetSystemCall">
<tt class="descclassname">VFS.</tt><tt class="descname">xGetSystemCall</tt><big>(</big><em>name</em><big>)</big> &rarr; int<a class="headerlink" href="#apsw.VFS.xGetSystemCall" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a pointer for the current method implementing the named
system call.  Return None if the call does not exist.</p>
</dd></dl>

<dl class="method">
<dt id="apsw.VFS.xNextSystemCall">
<tt class="descclassname">VFS.</tt><tt class="descname">xNextSystemCall</tt><big>(</big><em>name</em><big>)</big> &rarr; String or None<a class="headerlink" href="#apsw.VFS.xNextSystemCall" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is repeatedly called to iterate over all of the system
calls in the vfs.  When called with None you should return the
name of the first system call.  In subsequent calls return the
name after the one passed in.  If name is the last system call
then return None.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Because of internal SQLite implementation semantics memory will
be leaked on each call to this function.  Consequently you
should build up the list of call names once rather than
repeatedly doing it.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="apsw.VFS.xOpen">
<tt class="descclassname">VFS.</tt><tt class="descname">xOpen</tt><big>(</big><em>name</em>, <em>flags</em><big>)</big> &rarr; VFSFile or similar object<a class="headerlink" href="#apsw.VFS.xOpen" title="Permalink to this definition">¶</a></dt>
<dd><p>This method should return a new file object based on name.  You
can return a <a class="reference internal" href="#apsw.VFSFile" title="apsw.VFSFile"><tt class="xref py py-class docutils literal"><span class="pre">VFSFile</span></tt></a> from a completely different VFS.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> &#8211; File to open.  Note that <em>name</em> may be <tt class="xref py py-const docutils literal"><span class="pre">None</span></tt> in which
case you should open a temporary file with a name of your
choosing.  May be an instance of <a class="reference internal" href="#apsw.URIFilename" title="apsw.URIFilename"><tt class="xref py py-class docutils literal"><span class="pre">URIFilename</span></tt></a>.</li>
<li><strong>flags</strong> &#8211; A list of two integers <tt class="docutils literal"><span class="pre">[inputflags,</span>
<span class="pre">outputflags]</span></tt>.  Each integer is one or more of the <a class="reference external" href="https://sqlite.org/c3ref/c_open_autoproxy.html">open flags</a> binary orred
together.  The <tt class="docutils literal"><span class="pre">inputflags</span></tt> tells you what SQLite wants.  For
example <tt class="xref py py-const docutils literal"><span class="pre">SQLITE_OPEN_DELETEONCLOSE</span></tt> means the file should
be automatically deleted when closed.  The <tt class="docutils literal"><span class="pre">outputflags</span></tt>
describes how you actually did open the file.  For example if you
opened it read only then <tt class="xref py py-const docutils literal"><span class="pre">SQLITE_OPEN_READONLY</span></tt> should be
set.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="apsw.VFS.xRandomness">
<tt class="descclassname">VFS.</tt><tt class="descname">xRandomness</tt><big>(</big><em>numbytes</em><big>)</big> &rarr; bytes<a class="headerlink" href="#apsw.VFS.xRandomness" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called once when SQLite needs to seed the random
number generator. It is called on the default VFS only. It is not
called again, even across <a class="reference internal" href="apsw.html#apsw.shutdown" title="apsw.shutdown"><tt class="xref py py-meth docutils literal"><span class="pre">apsw.shutdown()</span></tt></a> calls.  You can
return less than the number of bytes requested including None. If
you return more then the surplus is ignored.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">(Python 2) string, buffer (Python 3) bytes, buffer</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="apsw.VFS.xSetSystemCall">
<tt class="descclassname">VFS.</tt><tt class="descname">xSetSystemCall</tt><big>(</big><em>name</em>, <em>pointer</em><big>)</big> &rarr; bool<a class="headerlink" href="#apsw.VFS.xSetSystemCall" title="Permalink to this definition">¶</a></dt>
<dd><p>Change a system call used by the VFS.  This is useful for testing
and some other scenarios such as sandboxing.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> &#8211; The string name of the system call</li>
<li><strong>pointer</strong> &#8211; A pointer provided as an int/long.  There is no
reference counting or other memory tracking of the pointer.  If
you provide one you need to ensure it is around for the lifetime
of this and any other related VFS.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Raise an exception to return an error.  If the system call does
not exist then raise <a class="reference internal" href="exceptions.html#apsw.NotFoundError" title="apsw.NotFoundError"><tt class="xref py py-exc docutils literal"><span class="pre">NotFoundError</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">True if the system call was set.  False if the system
call is not known.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="apsw.VFS.xSleep">
<tt class="descclassname">VFS.</tt><tt class="descname">xSleep</tt><big>(</big><em>microseconds</em><big>)</big> &rarr; integer<a class="headerlink" href="#apsw.VFS.xSleep" title="Permalink to this definition">¶</a></dt>
<dd><p>Pause exection of the thread for at least the specified number of
microseconds (millionths of a second).  This routine is typically called from the busy handler.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">How many microseconds you actually requested the
operating system to sleep for. For example if your operating
system sleep call only takes seconds then you would have to have
rounded the microseconds number up to the nearest second and
should return that rounded up value.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="vfsfile-class">
<h2>VFSFile class<a class="headerlink" href="#vfsfile-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="apsw.VFSFile">
<em class="property">class </em><tt class="descname">VFSFile</tt><big>(</big><em>vfs</em>, <em>name</em>, <em>flags</em><big>)</big><a class="headerlink" href="#apsw.VFSFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Wraps access to a file.  You only need to derive from this class
if you want the file object returned from <a class="reference internal" href="#apsw.VFS.xOpen" title="apsw.VFS.xOpen"><tt class="xref py py-meth docutils literal"><span class="pre">VFS.xOpen()</span></tt></a> to
inherit from an existing VFS implementation.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">All file sizes and offsets are 64 bit quantities even on 32 bit
operating systems.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>vfs</strong> &#8211; The vfs you want to inherit behaviour from.  You can
use an empty string <tt class="docutils literal"><span class="pre">&quot;&quot;</span></tt> to inherit from the default vfs.</li>
<li><strong>name</strong> &#8211; The name of the file being opened.  May be an instance of <a class="reference internal" href="#apsw.URIFilename" title="apsw.URIFilename"><tt class="xref py py-class docutils literal"><span class="pre">URIFilename</span></tt></a>.</li>
<li><strong>flags</strong> &#8211; A two list <tt class="docutils literal"><span class="pre">[inflags,</span> <span class="pre">outflags]</span></tt> as detailed in <a class="reference internal" href="#apsw.VFS.xOpen" title="apsw.VFS.xOpen"><tt class="xref py py-meth docutils literal"><span class="pre">VFS.xOpen()</span></tt></a>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Raises ValueError:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first last">If the named VFS is not registered.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the VFS that you inherit from supports <a class="reference internal" href="tips.html#wal"><em>write ahead
logging</em></a> then your <a class="reference internal" href="#apsw.VFSFile" title="apsw.VFSFile"><tt class="xref py py-class docutils literal"><span class="pre">VFSFile</span></tt></a> will also support the
xShm methods necessary to implement wal.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#apsw.VFS.xOpen" title="apsw.VFS.xOpen"><tt class="xref py py-meth docutils literal"><span class="pre">VFS.xOpen()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="apsw.VFSFile.excepthook">
<tt class="descclassname">VFSFile.</tt><tt class="descname">excepthook</tt><big>(</big><em>etype</em>, <em>evalue</em>, <em>etraceback</em><big>)</big><a class="headerlink" href="#apsw.VFSFile.excepthook" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when there has been an exception in a <a class="reference internal" href="#apsw.VFSFile" title="apsw.VFSFile"><tt class="xref py py-class docutils literal"><span class="pre">VFSFile</span></tt></a>
routine.  The default implementation calls <tt class="docutils literal"><span class="pre">sys.excepthook</span></tt> and
if that fails then <tt class="docutils literal"><span class="pre">PyErr_Display</span></tt>.  The three arguments
correspond to what <tt class="docutils literal"><span class="pre">sys.exc_info()</span></tt> would return.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>etype</strong> &#8211; The exception type</li>
<li><strong>evalue</strong> &#8211; The exception  value</li>
<li><strong>etraceback</strong> &#8211; The exception traceback.  Note this
includes all frames all the way up to the thread being started.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="apsw.VFSFile.xCheckReservedLock">
<tt class="descclassname">VFSFile.</tt><tt class="descname">xCheckReservedLock</tt><big>(</big><big>)</big><a class="headerlink" href="#apsw.VFSFile.xCheckReservedLock" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if any database connection (in this or another process)
has a lock other than <a class="reference external" href="https://sqlite.org/c3ref/c_lock_exclusive.html">SQLITE_LOCK_NONE or SQLITE_LOCK_SHARED</a>.</p>
</dd></dl>

<dl class="method">
<dt id="apsw.VFSFile.xClose">
<tt class="descclassname">VFSFile.</tt><tt class="descname">xClose</tt><big>(</big><big>)</big><a class="headerlink" href="#apsw.VFSFile.xClose" title="Permalink to this definition">¶</a></dt>
<dd><p>Close the database. Note that even if you return an error you should
still close the file.  It is safe to call this method mutliple
times.</p>
</dd></dl>

<dl class="method">
<dt id="apsw.VFSFile.xDeviceCharacteristics">
<tt class="descclassname">VFSFile.</tt><tt class="descname">xDeviceCharacteristics</tt><big>(</big><big>)</big> &rarr; int<a class="headerlink" href="#apsw.VFSFile.xDeviceCharacteristics" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <a class="reference external" href="https://sqlite.org/c3ref/c_iocap_atomic.html">I/O capabilities</a> (bitwise or of
appropriate values). If you do not implement the function or have an
error then 0 (the SQLite default) is returned.</p>
</dd></dl>

<dl class="method">
<dt id="apsw.VFSFile.xFileControl">
<tt class="descclassname">VFSFile.</tt><tt class="descname">xFileControl</tt><big>(</big><em>op</em>, <em>ptr</em><big>)</big> &rarr; bool<a class="headerlink" href="#apsw.VFSFile.xFileControl" title="Permalink to this definition">¶</a></dt>
<dd><p>Receives <a class="reference external" href="https://sqlite.org/c3ref/file_control.html">file control</a> request typically
issued by <a class="reference internal" href="connection.html#apsw.Connection.filecontrol" title="apsw.Connection.filecontrol"><tt class="xref py py-meth docutils literal"><span class="pre">Connection.filecontrol()</span></tt></a>.  See
<a class="reference internal" href="connection.html#apsw.Connection.filecontrol" title="apsw.Connection.filecontrol"><tt class="xref py py-meth docutils literal"><span class="pre">Connection.filecontrol()</span></tt></a> for an example of how to pass a
Python object to this routine.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>op</strong> &#8211; A numeric code.  Codes below 100 are reserved for SQLite
internal use.</li>
<li><strong>ptr</strong> &#8211; An integer corresponding to a pointer at the C level.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A boolean indicating if the op was understood</p>
</td>
</tr>
</tbody>
</table>
<p>As of SQLite 3.6.10, this method is called by SQLite if you have
inherited from an underlying VFSFile.  Consequently ensure you pass
any unrecognised codes through to your super class.  For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">xFileControl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">ptr</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">op</span><span class="o">==</span><span class="mi">1027</span><span class="p">:</span>
        <span class="n">process_quick</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">op</span><span class="o">==</span><span class="mi">1028</span><span class="p">:</span>
        <span class="n">obj</span><span class="o">=</span><span class="n">ctypes</span><span class="o">.</span><span class="n">py_object</span><span class="o">.</span><span class="n">from_address</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># this ensures superclass implementation is called</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">MyFile</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">xFileControl</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">ptr</span><span class="p">)</span>
    <span class="c"># we understood the op</span>
    <span class="k">return</span> <span class="bp">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="apsw.VFSFile.xFileSize">
<tt class="descclassname">VFSFile.</tt><tt class="descname">xFileSize</tt><big>(</big><big>)</big> &rarr; int<a class="headerlink" href="#apsw.VFSFile.xFileSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the size of the file in bytes.  Remember that file sizes are
64 bit quantities even on 32 bit operating systems.</p>
</dd></dl>

<dl class="method">
<dt id="apsw.VFSFile.xLock">
<tt class="descclassname">VFSFile.</tt><tt class="descname">xLock</tt><big>(</big><em>level</em><big>)</big><a class="headerlink" href="#apsw.VFSFile.xLock" title="Permalink to this definition">¶</a></dt>
<dd><p>Increase the lock to the level specified which is one of the
<a class="reference external" href="https://sqlite.org/c3ref/c_lock_exclusive.html">SQLITE_LOCK</a>
family of constants. If you can&#8217;t increase the lock level because
someone else has locked it, then raise <a class="reference internal" href="exceptions.html#apsw.BusyError" title="apsw.BusyError"><tt class="xref py py-exc docutils literal"><span class="pre">BusyError</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="apsw.VFSFile.xRead">
<tt class="descclassname">VFSFile.</tt><tt class="descname">xRead</tt><big>(</big><em>amount</em>, <em>offset</em><big>)</big> &rarr; bytes<a class="headerlink" href="#apsw.VFSFile.xRead" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the specified <em>amount</em> of data starting at <em>offset</em>. You
should make every effort to read all the data requested, or return
an error. If you have the file open for non-blocking I/O or if
signals happen then it is possible for the underlying operating
system to do a partial read. You will need to request the
remaining data. Except for empty files SQLite considers short
reads to be a fatal error.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>amount</strong> &#8211; Number of bytes to read</li>
<li><strong>offset</strong> &#8211; Where to start reading. This number may be 64 bit once the database is larger than 2GB.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">(Python 2) string, buffer.  (Python 3) bytes, buffer</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="apsw.VFSFile.xSectorSize">
<tt class="descclassname">VFSFile.</tt><tt class="descname">xSectorSize</tt><big>(</big><big>)</big> &rarr; int<a class="headerlink" href="#apsw.VFSFile.xSectorSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the native underlying sector size. SQLite uses the value
returned in determining the default database page size. If you do
not implement the function or have an error then 4096 (the SQLite
default) is returned.</p>
</dd></dl>

<dl class="method">
<dt id="apsw.VFSFile.xSync">
<tt class="descclassname">VFSFile.</tt><tt class="descname">xSync</tt><big>(</big><em>flags</em><big>)</big><a class="headerlink" href="#apsw.VFSFile.xSync" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure data is on the disk platters (ie could survive a power
failure immediately after the call returns) with the <a class="reference external" href="https://sqlite.org/c3ref/c_sync_dataonly.html">sync flags</a> detailing what
needs to be synced.  You can sync more than what is requested.</p>
</dd></dl>

<dl class="method">
<dt id="apsw.VFSFile.xTruncate">
<tt class="descclassname">VFSFile.</tt><tt class="descname">xTruncate</tt><big>(</big><em>newsize</em><big>)</big><a class="headerlink" href="#apsw.VFSFile.xTruncate" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the file length to <em>newsize</em> (which may be more or less than the
current length).</p>
</dd></dl>

<dl class="method">
<dt id="apsw.VFSFile.xUnlock">
<tt class="descclassname">VFSFile.</tt><tt class="descname">xUnlock</tt><big>(</big><em>level</em><big>)</big><a class="headerlink" href="#apsw.VFSFile.xUnlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Decrease the lock to the level specified which is one of the
<a class="reference external" href="https://sqlite.org/c3ref/c_lock_exclusive.html">SQLITE_LOCK</a>
family of constants.</p>
</dd></dl>

<dl class="method">
<dt id="apsw.VFSFile.xWrite">
<tt class="descclassname">VFSFile.</tt><tt class="descname">xWrite</tt><big>(</big><em>data</em>, <em>offset</em><big>)</big><a class="headerlink" href="#apsw.VFSFile.xWrite" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the <em>data</em> starting at absolute <em>offset</em>. You must write all the data
requested, or return an error. If you have the file open for
non-blocking I/O or if signals happen then it is possible for the
underlying operating system to do a partial write. You will need to
write the remaining data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>offset</strong> &#8211; Where to start writing. This number may be 64 bit once the database is larger than 2GB.</li>
<li><strong>data</strong> &#8211; (Python 2) string, (Python 3) bytes</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="urifilename-class">
<h2>URIFilename class<a class="headerlink" href="#urifilename-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="apsw.URIFilename">
<em class="property">class </em><tt class="descname">URIFilename</tt><a class="headerlink" href="#apsw.URIFilename" title="Permalink to this definition">¶</a></dt>
<dd><p>SQLite uses a convoluted method of storing <a class="reference external" href="https://sqlite.org/uri.html">uri parameters</a> after the filename binding the
C filename representation and parameters together.  This class
encapsulates that binding.  The <a class="reference internal" href="example.html#example-vfs"><em>example</em></a> shows
usage of this class.</p>
<p>Your <a class="reference internal" href="#apsw.VFS.xOpen" title="apsw.VFS.xOpen"><tt class="xref py py-meth docutils literal"><span class="pre">VFS.xOpen()</span></tt></a> method will generally be passed one of
these instead of a string as the filename if the URI flag was used
or the main database flag is set.</p>
<p>You can safely pass it on to the <a class="reference internal" href="#apsw.VFSFile" title="apsw.VFSFile"><tt class="xref py py-class docutils literal"><span class="pre">VFSFile</span></tt></a> constructor
which knows how to get the name back out.</p>
</dd></dl>

<dl class="method">
<dt id="apsw.URIFilename.filename">
<tt class="descclassname">URIFilename.</tt><tt class="descname">filename</tt><big>(</big><big>)</big> &rarr; str<a class="headerlink" href="#apsw.URIFilename.filename" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the filename.</p>
</dd></dl>

<span class="target" id="index-2"></span><dl class="method">
<dt id="apsw.URIFilename.uri_boolean">
<tt class="descclassname">URIFilename.</tt><tt class="descname">uri_boolean</tt><big>(</big><em>name</em>, <em>default</em><big>)</big> &rarr; bool<a class="headerlink" href="#apsw.URIFilename.uri_boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the boolean value for parameter <cite>name</cite> or <cite>default</cite> if not
present.</p>
<p>Calls: <a class="reference external" href="https://sqlite.org/c3ref/uri_boolean.html">sqlite3_uri_boolean</a></p>
</dd></dl>

<span class="target" id="index-3"></span><dl class="method">
<dt id="apsw.URIFilename.uri_int">
<tt class="descclassname">URIFilename.</tt><tt class="descname">uri_int</tt><big>(</big><em>name</em>, <em>default</em><big>)</big> &rarr; int<a class="headerlink" href="#apsw.URIFilename.uri_int" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the integer value for parameter <cite>name</cite> or <cite>default</cite> if not
present.</p>
<p>Calls: <a class="reference external" href="https://sqlite.org/c3ref/uri_boolean.html">sqlite3_uri_int64</a></p>
</dd></dl>

<span class="target" id="index-4"></span><dl class="method">
<dt id="apsw.URIFilename.uri_parameter">
<tt class="descclassname">URIFilename.</tt><tt class="descname">uri_parameter</tt><big>(</big><em>name</em><big>)</big> &rarr; str<a class="headerlink" href="#apsw.URIFilename.uri_parameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of parameter <cite>name</cite> or None.</p>
<p>Calls: <a class="reference external" href="https://sqlite.org/c3ref/uri_boolean.html">sqlite3_uri_parameter</a></p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Virtual File System (VFS)</a><ul>
<li><a class="reference internal" href="#exceptions-and-errors">Exceptions and errors</a></li>
<li><a class="reference internal" href="#vfs-class">VFS class</a></li>
<li><a class="reference internal" href="#vfsfile-class">VFSFile class</a></li>
<li><a class="reference internal" href="#urifilename-class">URIFilename class</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="vtable.html"
                        title="previous chapter">Virtual Tables</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="shell.html"
                        title="next chapter">Shell</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/vfs.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="shell.html" title="Shell"
             >next</a> |</li>
        <li class="right" >
          <a href="vtable.html" title="Virtual Tables"
             >previous</a> |</li>
        <li><a href="index.html">APSW 3.8.8.2-r1 documentation</a> &raquo;</li> 
      </ul>
    </div>

    <div class="footer">
        &copy; <a href="copyright.html">Copyright</a> 2004-2015, Roger Binns &lt;rogerb@rogerbinns.com&gt;.
      Last updated on Feb 01, 2015.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
<div class="footer">This page uses <a href="http://analytics.google.com/">
Google Analytics</a> to collect statistics. You can disable it by blocking
the JavaScript coming from www.google-analytics.com.
<script type="text/javascript">
  (function() {
    var ga = document.createElement('script');
    ga.src = ('https:' == document.location.protocol ?
              'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    ga.setAttribute('async', 'true');
    document.documentElement.firstChild.appendChild(ga);
  })();
</script>
</div>

  </body>
</html>